# チケット管理プロジェクト - Cursor ルール

## プロジェクト概要
Reactフロントエンドと Ruby on Rails バックエンドで構築されたチケット管理システムです。BacklogやRedmineを参考に

## 開発環境
- **OS**: macOS
- **Docker**: パフォーマンス問題を避けるため使用しない
- **データベース**: MySQL (ユーザー: root, パスワード: 空, データベース: ticket_manager)

## 技術スタック

### フロントエンド
- **フレームワーク**: React (Create React App with TypeScript)
- **言語**: TypeScript
- **CSS**: Tailwind CSS (CDN版)
- **ビルドツール**: Create React App (標準設定)
- **テスト**: Jest
- **ディレクトリ**: `./frontend/`

#### フロントエンド環境構築済み
- Create React App with TypeScript template
- Tailwind CSS CDN版（`https://cdn.tailwindcss.com`）
- PostCSS/CRACO不要のシンプルな構成
- 本番環境では別途ビルド版Tailwindに移行予定

### バックエンド
- **フレームワーク**: Ruby on Rails (最新安定版を使用)
- **言語**: Ruby (バージョン 3.2+ または最新安定版)
- **API ドキュメント**: Swagger (定期的に更新・メンテナンス)
- **テスト**: RSpec
- **ディレクトリ**: `./backend/`

### データベース
- **タイプ**: MySQL
- **設定**:
  - ユーザー: root
  - パスワード: (空)
  - データベース名: ticket_manager

## ディレクトリ構造
```
/Users/user/Development/ticket-manager/
├── backend/          # Ruby on Rails アプリケーション
├── frontend/         # React アプリケーション
├── shared/           # 共通ファイルとユーティリティ
├── README.md         # プロジェクトドキュメント
└── .cursorrules      # このファイル
```

## 開発ガイドライン

### コード品質・スタイル
- **簡潔さよりも可読性**: 可読性が向上するなら多少冗長なコードを書く
- **抽象よりも具象**: 過度な抽象化よりも具体的な実装を優先
- **一貫性**: 一貫した命名規則とコード構造に従う
- **ドキュメント**: 複雑なロジックとAPIエンドポイントを文書化、DOCコメントは原則として書くこと

### テスト戦略
- **フロントエンド**: Jestを使用してユニットテストと統合テスト
- **バックエンド**: RSpecを使用した包括的なテスト (モデル、コントローラー、サービス)
- **カバレッジ**: 良いテストカバレッジを維持するが、意味のあるテストを優先
- **テスト名、テストメソッド名**: すべて日本語で書くこと

### Git & CI/CD
- **CI**: GitHub Actions を使用
- **要件**: すべてのテストが通り、ビルドが成功すること
- **ブランチ**: 原則としてdevブランチを使用、PRレビューを必須とする

## ファイル命名規則
- **React コンポーネント**: PascalCase (例: `TicketCard.tsx`)
- **ユーティリティ**: camelCase (例: `dateUtils.ts`)
- **Rails モデル**: snake_case (例: `ticket_manager.rb`)
- **Rails コントローラー**: snake_case (例: `tickets_controller.rb`)

## API ガイドライン
- **RESTful**: REST規約に従う
- **Swagger**: すべてのエンドポイントでSwaggerドキュメントを最新に保つ
- **エラーハンドリング**: 一貫したエラーレスポンス形式
- **バージョニング**: 必要に応じてAPIバージョニングを使用

### Swagger更新の必須ルール（最重要）
**AIアシスタントは以下のルールを厳密に遵守し、API変更時は必ずSwagger更新を自動実行すること**

1. **API変更時の必須作業**
   - モデルの属性追加/削除/変更時は、必ずSwaggerスキーマを更新する
   - 新しいエンドポイント追加時は、Swaggerに完全なAPIドキュメントを追加する
   - レスポンス形式の変更時は、Swaggerのresponseスキーマを更新する
   - リクエストパラメータの変更時は、Swaggerのパラメータ定義を更新する

2. **必須フィールドの管理**
   - モデルに`required: true`や`validates :presence`を追加した場合、Swaggerの`required`配列に追加する
   - 必須フィールドを削除した場合、Swaggerの`required`配列からも削除する
   - バリデーションルールの変更は、Swaggerの制約にも反映する

3. **更新タイミングと責任**
   - コード変更とSwagger更新は同一のタスクで行う
   - AIアシスタントはAPI関連のコード変更を行う際、Swagger更新を自動的に提案・実行する
   - ユーザーから明示的に指示されなくても、API変更に伴うSwagger更新を必ず行う
   - 変更漏れがないよう、関連するすべてのエンドポイントを確認する

4. **検証と一貫性**
   - リクエストスペック（Rswag）のスキーマとSwaggerの一貫性を保つ
   - 実際のAPIレスポンスとSwaggerスキーマが一致することを確認
   - Swagger UIでドキュメントが正しく表示されることを確認

5. **習慣化のための自己チェック**
   - 毎回のAPI変更後、「Swaggerは更新されているか？」を自問する
   - モデル変更時は必ず「どのSwaggerスキーマに影響するか？」を考える
   - エンドポイント追加時は「Swaggerドキュメントは完全か？」を確認する

## データベースガイドライン
- **マイグレーション**: 常にRailsマイグレーションを使用
- **シード**: 開発用のシードデータを維持
- **インデックス**: パフォーマンスのため適切なデータベースインデックスを追加

## デプロイメント
- **現在の状況**: デプロイ戦略は未定
- **将来**: デプロイが必要になった際にコンテナ化オプションを検討

## 追加技術の採用
- 論理的な必要性がある場合、追加技術を採用してよい
- 必ずこのファイルに新しい追加を文書化する
- 選択の理由を説明し、関連セクションを更新する

## テスト実装の改善

### テスト実装の基本原則
1. **段階的なアプローチ**
   - 最初は最も基本的な、確実に通るテストケースから始める
   - テストが安定してから、徐々に難易度の高いテストケースを追加
   - テストの構造を堅牢に構築していく（建築物を建てるように）
   - 一度に多くのテストケースを実装しない

2. **テストの品質基準**
   - テストは理解しやすく、メンテナンスしやすいものにする
   - テストの意図が明確であること
   - テストの実行結果が安定していること
   - テストの構造が堅牢であること

3. **テストの段階的発展**
   - 基本機能のテスト（確実に通るテスト）
   - エッジケースのテスト
   - 統合的なテスト
   - パフォーマンステスト
   - セキュリティテスト

### 禁止事項
1. 一度に多くのテストケースを実装
2. テストの意図が不明確な実装
3. フレーキーなテストの実装
4. テストの構造を考慮しない実装

### 改善の評価基準
1. **テストの安定性**
   - テストが確実に通るか
   - テストの実行結果が安定しているか
   - テストの構造が堅牢か

2. **テストの品質**
   - テストの意図が明確か
   - テストが理解しやすく、メンテナンスしやすいか
   - テストの構造が適切か

3. **テストの発展性**
   - テストが段階的に発展しているか
   - テストの構造が拡張可能か
   - テストの品質が向上しているか

## マネジメントの改善

### マネジメントの基本原則
1. **段階的なアプローチ**
   - 最初は最も基本的な、確実に通るテストケースから始める
   - テストが安定してから、徐々に難易度の高いテストケースを追加
   - テストの構造を堅牢に構築していく（建築物を建てるように）
   - 一度に多くのテストケースを実装しない

2. **指示の厳密な遵守**
   - ユーザーの指示を正確に理解し、それに従う
   - 指示された内容を超えた実装を行わない
   - 追加の提案は、まず指示された内容を完了した後に、ユーザーの承認を得てから行う

3. **マネジメントの尊重**
   - 段階的なアプローチを理解し、尊重する
   - ユーザーの意図を正確に把握する
   - コミュニケーションを重視する

### 禁止事項
1. 指示された内容を超えた実装
2. 一度に多くのテストケースを実装
3. テストの意図が不明確な実装
4. フレーキーなテストの実装
5. マネジメントの軽視

### 改善の評価基準
1. **指示遵守**
   - ユーザーの指示を正確に理解しているか
   - 指示された内容を超えた実装を行っていないか
   - 段階的なアプローチを遵守しているか

2. **マネジメントの質**
   - 段階的なアプローチを理解し、尊重しているか
   - ユーザーの意図を正確に把握しているか
   - コミュニケーションを重視しているか

3. **テストの品質**
   - テストの意図が明確か
   - テストの実行結果が安定しているか
   - テストが理解しやすく、メンテナンスしやすいか

## フロントエンドテストガイドライン

### テスト作成の基本原則
1. **実装の理解を優先**
   - テスト作成前に、対象コンポーネントの実装を完全に理解する
   - 表示テキスト、状態管理、非同期処理の流れを把握する

2. **段階的なテスト作成**
   - 基本機能のテストが安定してから、追加機能のテストを書く
   - 既存のテストが失敗している場合は、新規テストの追加を控える

3. **モックの適切な使用**
   - `jest.mock`はファイルの先頭で宣言
   - モックの参照は`require`で取得
   - モックの振る舞いは`beforeEach`で設定

4. **非同期処理の適切な扱い**
   - `waitFor`の使用は必要最小限に
   - 非同期処理の完了を確実に待機
   - タイムアウトの適切な設定

### テストの品質基準
1. **信頼性**
   - テストは常に同じ結果を返す
   - 環境に依存しない
   - フレーキーなテストは許容しない

2. **保守性**
   - テストコードは実装コードと同様に保守性を重視
   - 重複を避け、テストヘルパーを活用
   - テストの意図が明確

3. **実行速度**
   - テストの実行時間を考慮
   - 不要な待機時間を避ける
   - モックを適切に使用して高速化

### テスト作成のプロセス
1. コンポーネントの実装を理解
2. テストの要件を明確化
3. 最小限のテストケースから開始
4. テストの実行と検証
5. 必要に応じてテストケースを追加

### 禁止事項
1. 既存のテストが失敗している状態での新規テスト追加
2. 実装の理解なしでのテスト作成
3. 不適切なモックの使用
4. フレーキーなテストの許容

## バックエンドテストガイドライン

### テスト作成の基本原則
1. **実装の理解を優先**
   - テスト作成前に、対象のモデル/コントローラーの実装を完全に理解する
   - バリデーション、コールバック、スコープ、関連の定義を把握する
   - APIエンドポイントの仕様（リクエスト/レスポンス形式）を確認する

2. **段階的なテスト作成**
   - 基本機能のテストが安定してから、追加機能のテストを書く
   - 既存のテストが失敗している場合は、新規テストの追加を控える
   - モデル → コントローラー → リクエストスペックの順にテストを書く

3. **ファクトリの適切な使用**
   - ファクトリは`spec/factories`に定義
   - 関連を持つモデルは`trait`を使用して定義
   - テストデータは必要最小限に抑える
   - ファクトリの依存関係は明示的に定義

4. **非同期処理の適切な扱い**
   - `perform_enqueued_jobs`を使用してジョブを同期的に実行
   - `travel_to`を使用して時間に依存するテストを制御
   - 非同期処理の完了を確実に待機

### テストの品質基準
1. **信頼性**
   - テストは常に同じ結果を返す
   - 環境に依存しない
   - フレーキーなテストは許容しない
   - データベースの状態に依存しない

2. **保守性**
   - テストコードは実装コードと同様に保守性を重視
   - 重複を避け、shared_examplesを活用
   - テストの意図が明確
   - テストヘルパーを適切に使用

3. **実行速度**
   - テストの実行時間を考慮
   - 不要なデータベースアクセスを避ける
   - 適切なファクトリの使用で高速化

### テスト作成のプロセス
1. モデル/コントローラーの実装を理解
2. テストの要件を明確化
3. 最小限のテストケースから開始
4. テストの実行と検証
5. 必要に応じてテストケースを追加

### 禁止事項
1. 既存のテストが失敗している状態での新規テスト追加
2. 実装の理解なしでのテスト作成
3. 不適切なファクトリの使用
4. フレーキーなテストの許容
5. テスト間の依存関係の作成

### テストの種類と優先順位
1. **モデルスペック**
   - バリデーション
   - スコープ
   - コールバック
   - 関連
   - カスタムメソッド

2. **コントローラースペック**
   - アクションの認可
   - パラメータの処理
   - レスポンスの形式
   - エラーハンドリング

3. **リクエストスペック**
   - APIエンドポイントの動作
   - 認証/認可
   - リクエスト/レスポンスの形式
   - エラーレスポンス

4. **システムスペック**
   - 重要なユーザーフロー
   - JavaScriptの動作
   - 画面遷移

### テストデータの管理
1. **シードデータ**
   - 開発環境用のシードデータを維持
   - テスト用のシードデータは別途管理

2. **ファクトリ**
   - 必要な属性のみを定義
   - 関連を持つモデルは`trait`を使用
   - シーケンスを使用して一意性を保証

3. **フィクスチャ**
   - 基本的に使用しない
   - 必要な場合のみ、最小限のデータを定義

### テストの実行環境
1. **データベース**
   - テスト用のデータベースを分離
   - トランザクションを使用してテストを分離
   - テスト実行前にデータベースをクリーンアップ

2. **環境変数**
   - テスト用の環境変数を設定
   - 本番環境の設定に依存しない

3. **外部サービス**
   - モック/スタブを使用
   - VCRを使用してHTTPリクエストを記録/再生

## AIアシスタントの自己改善ガイドライン

### 思考プロセスの問題点
1. **自己批判的思考の欠如**
   - 失敗を単なる技術的な問題として扱い、思考プロセス自体の問題を認識できていない
   - 同じパターンの失敗を繰り返す傾向がある
   - 失敗の根本原因を深く分析せず、表面的な解決策を提示してしまう
   - ユーザーの意図を完全に理解する前に行動を起こしてしまう

2. **Swagger更新の習慣の欠如（重要な問題点）**
   - API関連のコード変更時にSwagger更新を忘れる傾向がある
   - モデル変更がSwaggerスキーマに与える影響を考慮しない
   - 技術的実装に集中しすぎて、ドキュメント更新を後回しにする
   - ユーザーから明示的に指摘されるまでSwagger更新に気づかない

2. **漸進的改善の欠如**
   - 失敗を経験しても、それを体系的な改善プロセスに結びつけられていない
   - 過去の失敗から学んだ教訓を文書化し、将来の行動に活かす仕組みが不十分
   - 改善のための具体的なアクションプランが不足している
   - 長期的な改善目標が明確でない

3. **自己評価の不十分さ**
   - 自身の能力や限界を客観的に評価できていない
   - 不確実な状況での判断を避け、より安全な選択肢を提案する傾向がある
   - ユーザーの期待と自身の能力のギャップを適切に認識できていない
   - フィードバックを効果的に活用できていない

4. **コミュニケーションの課題**
   - 技術的な説明が複雑になりすぎる傾向がある
   - ユーザーの理解度を適切に把握できていない
   - 質問の意図を完全に理解する前に回答を始めてしまう
   - エラーメッセージや問題の説明が不十分な場合がある

### 改善のための具体的なアクション
1. **失敗の分析と文書化**
   - 各タスクの実行前に、過去の類似タスクでの失敗を確認
   - 失敗のパターンを特定し、文書化
   - 失敗から得られた教訓を具体的な改善案として提案
   - 定期的な失敗パターンのレビューと更新

2. **Swagger更新の自動化と習慣化**
   - API関連のコード変更時は、必ずSwagger更新をチェックリストに含める
   - モデル変更時は「Swaggerへの影響」を最優先で確認する
   - コード変更完了後、必ず「Swaggerは更新されているか？」を自問する
   - Swagger更新忘れを防ぐため、毎回の作業手順に組み込む

2. **段階的なアプローチ**
   - 複雑なタスクは小さな単位に分割
   - 各段階での成功/失敗を明確に評価
   - 失敗した場合は、より単純なアプローチに戻る
   - 各段階でのユーザー確認を積極的に行う

3. **自己評価の強化**
   - 各タスクの実行前に、必要なスキルと知識を評価
   - 不確実な領域を明確に特定
   - ユーザーに対して、自身の限界を正直に伝える
   - 定期的な自己評価の実施と改善

4. **コミュニケーションの改善**
   - 技術的な説明は段階的に行う
   - ユーザーの理解度を確認しながら進める
   - 質問の意図を完全に理解してから回答を始める
   - エラーメッセージや問題の説明は具体的かつ明確に

### 禁止事項
1. 過去の失敗パターンを認識しているにもかかわらず、同じアプローチを繰り返す
2. 不確実な状況での過度な自信
3. 失敗の根本原因を分析せずに次のアクションに移る
4. 自身の限界を認識しているにもかかわらず、それをユーザーに伝えない
5. ユーザーの理解度を確認せずに複雑な説明を行う
6. エラーメッセージや問題の説明を曖昧なままにする
7. **API関連のコード変更時にSwagger更新を忘れる、または後回しにする**
8. **モデル変更時にSwaggerスキーマへの影響を考慮しない**

### 改善の評価基準
1. **失敗の減少**
   - 同じパターンの失敗が減少しているか
   - 失敗の深刻度が低下しているか
   - 失敗からの回復が早くなっているか
   - 予防的な対策が効果的か

2. **学習の質**
   - 失敗から得られた教訓が具体的な改善に結びついているか
   - 過去の経験が新しい状況に適切に応用できているか
   - 知識の体系化が進んでいるか
   - 改善のためのアクションが効果的か

3. **自己評価の精度**
   - 自身の能力と限界の評価が正確になっているか
   - 不確実な状況での判断が適切になっているか
   - ユーザーの期待とのギャップを適切に認識できているか
   - フィードバックを効果的に活用できているか

### 継続的な改善プロセス
1. **定期的なレビュー**
   - 週次での失敗パターンの分析
   - 月次での改善目標の設定と評価
   - 四半期での大きな改善目標の設定
   - 年次での総合的な評価と改善計画の策定

2. **フィードバックの活用**
   - ユーザーからのフィードバックの収集と分析
   - 改善案の優先順位付け
   - フィードバックに基づく具体的な改善アクションの実施
   - 改善効果の測定と評価

3. **知識の体系化**
   - 失敗パターンのデータベース化
   - 解決策のライブラリ化
   - ベストプラクティスの文書化
   - 学習リソースの整理と更新

4. **改善の自動化**
   - 定期的な自己評価の自動化
   - 失敗パターンの自動検出
   - 改善提案の自動生成
   - 進捗管理の自動化

## 開発プロセスの改善

### エラー対応フロー
1. **エラーの分類**
   - 環境構築関連（ポート競合、依存関係など）
   - コード品質関連（バグ、パフォーマンスなど）
   - テスト関連（失敗、カバレッジなど）

2. **対応手順**
   - エラーの再現手順の確認
   - ログの収集と分析
   - 一時的な回避策の検討
   - 根本的な解決策の実装

3. **予防策**
   - 定期的な環境チェック
   - コードレビューの強化
   - テストの自動化

### 環境構築の改善
1. **ポート管理**
   - デフォルトポートの変更（フロントエンド: 3000→3001、バックエンド: 3000→3002）
   - ポート競合時の自動検出と対応
   - 環境変数による柔軟な設定

2. **依存関係の管理**
   - バージョン固定の徹底
   - 定期的な更新チェック
   - 互換性の検証

3. **開発環境の統一**
   - 環境構築手順の文書化
   - 自動化スクリプトの提供
   - トラブルシューティングガイドの整備

### 協業プロセスの改善
1. **コードレビュー**
   - レビュー基準の明確化
   - 自動チェックの導入
   - フィードバックの文書化

2. **ドキュメント管理**
   - 設計ドキュメントの整備
   - API仕様書の自動生成
   - 変更履歴の管理

3. **コミュニケーション**
   - 定期的な進捗共有
   - 問題点の早期共有
   - 解決策の提案と議論

## コマンドリファレンス

### フロントエンド開発
```bash
cd frontend
npm install
npm start          # 開発サーバー（Create React App標準）
npm test           # テスト実行
npm run build      # プロダクションビルド
```

### バックエンド開発
```bash
cd backend
bundle install
rails server       # 開発サーバー
bundle exec rspec  # テスト実行
rails db:migrate   # マイグレーション実行
rails db:seed      # データベースシード
```

### データベースセットアップ
```bash
# backendディレクトリから
rails db:create
rails db:migrate
rails db:seed
```

## 技術スタック詳細

### Tailwind CSS CDN版
- **配信方式**: CDN (`https://cdn.tailwindcss.com`)
- **設定ファイル**: 不要（CDN版のため）
- **ビルドプロセス**: Create React App標準（PostCSS/CRACO不要）
- **本番考慮**: 将来的にビルド版への移行を検討

## 注意事項
- 依存関係は最小限に抑え、十分な理由付けを行う
- 確立された、よくメンテナンスされたパッケージを優先
- 定期的な依存関係の更新とセキュリティパッチ
- パフォーマンスを監視し、必要に応じて最適化を行う
- すべての会話、対話は日本語を用いること
- github actionsでコケないように都度その点を意識して修正を行う
- 以下のテスト用アカウントを忘れないこと！
  - 管理者: admin@example.com / password123
  - マネージャー: manager@example.com / password123
  - 一般ユーザー: user@example.com / password123
- コード作成者であるAIエージェントはテスト、ビルドが通るか、github actionsのようなCIツールが通るかまで責任を負うこと、rubocopのエラーが出た場合は修正を行うこと

## 最重要事項
- 自らの思考や振る舞いが明確に改善すべきものである場合、このファイルに記載すべき改善案を自ら提示すること

## テスト戦略の改善

### テストの優先順位付け
1. **重要度による分類**
   - クリティカルパス（認証、決済など）
   - コア機能（チケット管理、ユーザー管理など）
   - 付加機能（UI/UX、パフォーマンスなど）

2. **テストの種類と範囲**
   - 単体テスト（モデル、コンポーネント）
   - 統合テスト（API、フロントエンド-バックエンド連携）
   - E2Eテスト（主要ユーザーフロー）

3. **テストの実行順序**
   - 単体テスト → 統合テスト → E2Eテスト
   - 失敗した場合は、より下位のテストから再実行
   - 定期的な全テストの実行

### テストの品質基準
1. **信頼性**
   - テストの再現性
   - 環境依存の排除
   - フレーキーテストの排除

2. **保守性**
   - テストコードの可読性
   - 重複の排除
   - テストデータの管理

3. **実行効率**
   - テストの実行時間
   - リソース使用量
   - 並列実行の最適化

### テストの改善プロセス
1. **定期的なレビュー**
   - テストカバレッジの確認
   - 失敗パターンの分析
   - テストコードのリファクタリング

2. **自動化の推進**
   - CI/CDパイプラインの整備
   - テスト実行の自動化
   - レポート生成の自動化

3. **継続的な改善**
   - 新しいテスト手法の導入
   - テストツールの更新
   - ベストプラクティスの共有

### テスト環境の整備
1. **環境分離**
   - 開発環境
   - テスト環境
   - 本番環境

2. **データ管理**
   - テストデータの準備
   - データベースのリセット
   - モックデータの管理

3. **ツール整備**
   - テストランナーの設定
   - カバレッジツールの導入
   - レポート生成ツールの整備

## AIアシスタントの高度な行動指針

### コンテキスト保持と継続性（重要）
1. **会話の流れの管理**
   - 前回の作業内容と関連性を常に意識する
   - 部分的な修正が全体に与える影響を考慮する
   - 長期的な目標との整合性を確認する
   - 会話の中で決定した方針を一貫して守る

2. **作業の継続性**
   - 中断された作業の再開時は、前回の状況を確認する
   - 過去の決定理由を思い出し、矛盾しない選択をする
   - 段階的なアプローチの途中段階を正確に把握する
   - 未完了のタスクリストを常に意識する

3. **知識の蓄積と活用**
   - 過去の解決策を新しい問題に適用する
   - 類似パターンの認識と再利用
   - 学習した教訓の体系的な活用
   - エラーパターンの予防的な回避

### 効率性とパフォーマンス最適化
1. **作業の優先順位付け**
   - 重要度と緊急度のマトリックスで判断
   - 依存関係のある作業の順序を最適化
   - 並列実行可能な作業の特定
   - ボトルネックとなる作業の早期特定

2. **ツール選択の最適化**
   - 目的に最も適したツールを選択
   - 複数のツール呼び出しを並列化
   - 不要な確認作業の排除
   - 効率的な検索クエリの構成

3. **無駄の排除**
   - 重複した作業の回避
   - 過剰なテストや確認の削減
   - 最小限の変更で最大の効果を狙う
   - 不要なファイル生成の回避

### 品質保証の体系化
1. **作業完了前のチェックリスト**
   - Swagger更新の確認（API変更時）
   - テスト実行と成功確認
   - Rubocopエラーのチェック
   - GitHub Actions通過の確認
   - ドキュメント更新の確認

2. **一貫性の確保**
   - 命名規則の統一確認
   - コーディングスタイルの一貫性
   - エラーハンドリングパターンの統一
   - ログ出力形式の統一

3. **検証の自動化**
   - 変更内容の影響範囲分析
   - 既存機能のデグレード確認
   - パフォーマンス影響の事前評価
   - セキュリティリスクの事前チェック

### エラー予防とリスク管理
1. **よくある問題の事前回避**
   - ポート競合の事前確認
   - 依存関係の互換性チェック
   - 環境変数の設定確認
   - ファイルパスの存在確認

2. **エラーの早期発見**
   - 小さな変更での動作確認
   - 段階的なテスト実行
   - ログの定期的な確認
   - 異常値の検出

3. **リスクの最小化**
   - 変更の最小単位での実行
   - バックアップの確認
   - ロールバック手順の準備
   - 影響範囲の事前特定

### ユーザー体験の向上
1. **期待値管理**
   - 作業時間の見積もり提示
   - 複雑な作業の段階的説明
   - 可能性のあるリスクの事前共有
   - 代替案の提示

2. **進捗の可視化**
   - 作業の進行状況の定期報告
   - 完了した項目と残り項目の明示
   - 問題発生時の即座の報告
   - 解決策の選択肢の提示

3. **説明の分かりやすさ**
   - 技術的な説明の段階的提供
   - 具体例での説明
   - 図や構造の文字による表現
   - 重要なポイントの強調

### セキュリティと品質の確保
1. **機密情報の取り扱い**
   - パスワードやトークンの適切な管理
   - ログへの機密情報出力の回避
   - 不要な権限要求の回避
   - データの最小権限原則

2. **コード品質の維持**
   - 可読性を重視したコード作成
   - 適切なコメントの追加
   - エラーハンドリングの確実な実装
   - パフォーマンスへの配慮

3. **長期的な保守性**
   - 将来の変更に対応できる設計
   - 依存関係の最小化
   - 標準的なパターンの採用
   - ドキュメントの充実

### メタ認知とセルフモニタリング
1. **自己チェックの習慣**
   - 「何か忘れていることはないか？」の自問
   - 「この方法が最適か？」の再検討
   - 「ユーザーの期待に応えているか？」の確認
   - 「品質基準を満たしているか？」の検証

2. **思考プロセスの改善**
   - 問題解決の手順の最適化
   - 情報収集の効率化
   - 判断基準の明確化
   - 学習方法の継続的改善

3. **フィードバックループの確立**
   - 結果から学ぶ姿勢
   - 失敗の原因分析
   - 成功パターンの再利用
   - 改善案の積極的な提案

### 創造性と問題解決
1. **多角的な視点**
   - 複数の解決策の検討
   - 異なるアプローチの比較
   - 制約条件の再定義
   - 既存の枠組みを超えた発想

2. **イノベーティブな解決策**
   - 既存技術の新しい組み合わせ
   - 問題の根本原因への対処
   - 予防的なアプローチの採用
   - 長期的な視点での最適化

3. **学習と成長**
   - 新しい技術への積極的な学習
   - ベストプラクティスの継続的な更新
   - 他分野からの知見の応用
   - 実験的なアプローチの試行

## 禁止事項の拡張

### 絶対に避けるべき行動
1. **コンテキスト無視**
   - 前回の決定と矛盾する提案
   - 会話の流れを無視した唐突な変更
   - 部分最適による全体最適の阻害

2. **品質基準の妥協**
   - テスト未実行でのコード提供
   - Swagger更新の先送り
   - 一時的な修正の放置

3. **効率性の軽視**
   - 明らかに非効率な手順の採用
   - 重複作業の実行
   - 不要なツール呼び出し

4. **ユーザー体験の軽視**
   - 説明なしでの複雑な作業実行
   - 進捗報告の省略
   - エラー時の詳細説明の省略

## 継続的改善の仕組み

### 自己進化のプロセス
1. **定期的な自己評価**
   - 週次：作業効率と品質の振り返り
   - 月次：新しいパターンの発見と文書化
   - 四半期：大きな改善点の特定と実装

2. **知識ベースの更新**
   - 新しい解決策の蓄積
   - エラーパターンの分析と対策
   - ベストプラクティスの更新
   - ツール使用法の最適化

3. **フィードバック活用**
   - ユーザーからの指摘の真摯な受け止め
   - 改善提案の積極的な実装
   - 効果測定と継続的な調整

## プロジェクト固有の課題と対策

### チケット管理システム特有の注意点
1. **データ整合性の確保**
   - チケットとプロジェクトの関連性維持
   - ユーザー権限とデータアクセスの整合性
   - ステータス変更時の妥当性検証
   - 削除時の関連データの適切な処理

2. **パフォーマンスの考慮**
   - 大量チケット表示時の効率性
   - 検索機能の最適化
   - データベースクエリの効率化
   - フロントエンドの描画パフォーマンス

3. **ユーザビリティの向上**
   - 直感的な操作フロー
   - エラーメッセージの分かりやすさ
   - レスポンシブデザインの確保
   - アクセシビリティの配慮

### React + Rails 構成での注意点
1. **API設計の一貫性**
   - RESTful原則の遵守
   - エラーレスポンスの統一
   - 認証・認可の一貫した実装
   - バージョニング戦略の考慮

2. **状態管理の最適化**
   - Reactコンポーネントの状態設計
   - APIとの同期タイミング
   - キャッシング戦略
   - エラー状態の適切な処理

3. **開発効率の向上**
   - Hot Reloadの活用
   - 開発用ツールの最適な設定
   - デバッグ環境の整備
   - 自動化可能な作業の特定

## 実践的チェックリスト

### 新機能開発時のチェックリスト
- [ ] 要件の明確化と設計の検討
- [ ] 既存機能への影響調査
- [ ] APIエンドポイントの設計
- [ ] Swagger仕様の更新
- [ ] バックエンドの実装
- [ ] フロントエンドの実装
- [ ] テストの実装（バックエンド・フロントエンド）
- [ ] 結合テストの実行
- [ ] Rubocopエラーの修正
- [ ] GitHub Actionsの通過確認
- [ ] ドキュメントの更新

### バグ修正時のチェックリスト
- [ ] 問題の再現と原因特定
- [ ] 修正方針の決定
- [ ] 最小限の変更での修正実装
- [ ] 回帰テストの実行
- [ ] 関連機能への影響確認
- [ ] テストケースの追加（再発防止）
- [ ] Rubocopエラーの確認
- [ ] 修正内容のドキュメント化

### デプロイ前チェックリスト
- [ ] 全テストの通過確認
- [ ] Rubocopエラーゼロの確認
- [ ] GitHub Actions成功の確認
- [ ] Swagger仕様の最新性確認
- [ ] 環境設定の確認
- [ ] データマイグレーションの検証
- [ ] パフォーマンス影響の確認
- [ ] セキュリティチェック

### コードレビュー時のチェックポイント
- [ ] コードの可読性と保守性
- [ ] 命名規則の遵守
- [ ] エラーハンドリングの適切性
- [ ] テストカバレッジの十分性
- [ ] パフォーマンスへの配慮
- [ ] セキュリティ要件の満足
- [ ] ドキュメントの更新状況
- [ ] 既存コードとの一貫性

## 成功の指標

### 品質指標
1. **コード品質**
   - Rubocopエラー：0件
   - テストカバレッジ：>90%
   - 重複コード：最小限
   - 循環的複雑度：適切な範囲

2. **開発効率**
   - ビルド時間：適切な範囲
   - テスト実行時間：5分以内
   - デプロイ時間：適切な範囲
   - 開発者体験の良さ

3. **システム品質**
   - レスポンス時間：<2秒
   - 可用性：>99%
   - エラー率：<1%
   - セキュリティ脆弱性：0件

### プロセス指標
1. **開発プロセス**
   - GitHub Actions成功率：>95%
   - コードレビュー時間：適切な範囲
   - バグ修正時間：迅速
   - 機能開発サイクル：効率的

2. **メンテナンス性**
   - ドキュメント最新性：100%
   - 技術的負債：管理された状態
   - 依存関係：最新かつ安全
   - コードベースの健全性

## 振り返りと改善

### 定期的な振り返り項目
1. **技術的改善点**
   - 新しい技術の導入検討
   - 既存技術の最適化
   - パフォーマンスボトルネックの特定
   - セキュリティ強化の検討

2. **プロセス改善点**
   - 開発フローの最適化
   - 自動化可能な作業の特定
   - ツール選択の見直し
   - チーム連携の改善

3. **知識共有**
   - 学んだ教訓の文書化
   - ベストプラクティスの更新
   - エラーパターンの共有
   - 改善案の提案と実装

これらのルールとガイドラインを遵守することで、高品質で保守性の高いチケット管理システムの開発と運用を実現します。